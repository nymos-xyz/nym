//! Node discovery mechanisms

use std::collections::{HashMap, HashSet};\nuse std::net::SocketAddr;\nuse std::time::{Duration, SystemTime, UNIX_EPOCH};\nuse serde::{Serialize, Deserialize};\nuse tokio::time::{interval, timeout};\nuse nym_crypto::{Hash256, SecurityLevel};\nuse nym_core::NymIdentity;\nuse crate::{\n    NetworkError, NetworkResult, PeerId, PeerInfo, PeerCapabilities,\n    NetworkMessage, MessageType, MessagePayload, DiscoveryPayload, PeerInfoPayload\n};\n\n/// Discovery configuration\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct DiscoveryConfig {\n    /// Bootstrap nodes\n    pub bootstrap_nodes: Vec<SocketAddr>,\n    /// Discovery interval in seconds\n    pub discovery_interval: u64,\n    /// Maximum peers to discover per round\n    pub max_peers_per_round: usize,\n    /// Discovery timeout in seconds\n    pub discovery_timeout: u64,\n    /// Minimum peer exchange interval\n    pub min_peer_exchange_interval: u64,\n    /// Maximum peer age before refresh\n    pub max_peer_age: u64,\n}\n\n/// Discovery state\n#[derive(Debug, Clone, PartialEq, Eq)]\npub enum DiscoveryState {\n    Initializing,\n    Bootstrapping,\n    Active,\n    Paused,\n    Stopped,\n}\n\n/// Discovery statistics\n#[derive(Debug, Clone, Default)]\npub struct DiscoveryStats {\n    /// Total discovery rounds\n    pub discovery_rounds: u64,\n    /// Successful discoveries\n    pub successful_discoveries: u64,\n    /// Failed discoveries\n    pub failed_discoveries: u64,\n    /// Peers discovered\n    pub peers_discovered: u64,\n    /// Bootstrap attempts\n    pub bootstrap_attempts: u64,\n    /// Last discovery timestamp\n    pub last_discovery: Option<u64>,\n}\n\n/// Node discovery service\npub struct NodeDiscovery {\n    /// Discovery configuration\n    config: DiscoveryConfig,\n    /// Current discovery state\n    state: DiscoveryState,\n    /// Known peers\n    known_peers: HashMap<PeerId, PeerDiscoveryInfo>,\n    /// Pending discovery requests\n    pending_requests: HashMap<Hash256, DiscoveryRequest>,\n    /// Discovery statistics\n    stats: DiscoveryStats,\n    /// Local identity\n    identity: NymIdentity,\n    /// Last peer exchange times\n    last_peer_exchange: HashMap<PeerId, u64>,\n}\n\n/// Peer discovery information\n#[derive(Debug, Clone)]\nstruct PeerDiscoveryInfo {\n    /// Peer information\n    peer_info: PeerInfo,\n    /// Discovery timestamp\n    discovered_at: u64,\n    /// Last seen timestamp\n    last_seen: u64,\n    /// Discovery source\n    source: DiscoverySource,\n    /// Verification status\n    verified: bool,\n}\n\n/// Discovery source\n#[derive(Debug, Clone)]\nenum DiscoverySource {\n    Bootstrap,\n    PeerExchange(PeerId),\n    Manual,\n    Incoming,\n}\n\n/// Discovery request\n#[derive(Debug, Clone)]\nstruct DiscoveryRequest {\n    /// Request ID\n    request_id: Hash256,\n    /// Target peer\n    target_peer: PeerId,\n    /// Request timestamp\n    timestamp: u64,\n    /// Request type\n    request_type: DiscoveryRequestType,\n}\n\n/// Discovery request types\n#[derive(Debug, Clone)]\nenum DiscoveryRequestType {\n    Bootstrap,\n    PeerExchange,\n    Refresh,\n}\n\nimpl Default for DiscoveryConfig {\n    fn default() -> Self {\n        Self {\n            bootstrap_nodes: vec![\n                \"127.0.0.1:8080\".parse().unwrap(),\n                \"127.0.0.1:8081\".parse().unwrap(),\n            ],\n            discovery_interval: 300, // 5 minutes\n            max_peers_per_round: 10,\n            discovery_timeout: 30,\n            min_peer_exchange_interval: 60, // 1 minute\n            max_peer_age: 3600, // 1 hour\n        }\n    }\n}\n\nimpl NodeDiscovery {\n    /// Create a new node discovery service\n    pub fn new(config: DiscoveryConfig, identity: NymIdentity) -> Self {\n        Self {\n            config,\n            state: DiscoveryState::Initializing,\n            known_peers: HashMap::new(),\n            pending_requests: HashMap::new(),\n            stats: DiscoveryStats::default(),\n            identity,\n            last_peer_exchange: HashMap::new(),\n        }\n    }\n    \n    /// Start the discovery service\n    pub async fn start(&mut self) -> NetworkResult<()> {\n        self.state = DiscoveryState::Bootstrapping;\n        \n        // Attempt bootstrap\n        self.bootstrap().await?;\n        \n        // Start discovery loop\n        self.state = DiscoveryState::Active;\n        \n        Ok(())\n    }\n    \n    /// Stop the discovery service\n    pub async fn stop(&mut self) {\n        self.state = DiscoveryState::Stopped;\n        self.pending_requests.clear();\n    }\n    \n    /// Bootstrap from known nodes\n    async fn bootstrap(&mut self) -> NetworkResult<()> {\n        self.stats.bootstrap_attempts += 1;\n        \n        for bootstrap_addr in &self.config.bootstrap_nodes.clone() {\n            match self.discover_from_bootstrap(*bootstrap_addr).await {\n                Ok(_) => {\n                    self.stats.successful_discoveries += 1;\n                    return Ok(());\n                }\n                Err(e) => {\n                    tracing::warn!(\"Bootstrap failed for {}: {:?}\", bootstrap_addr, e);\n                    self.stats.failed_discoveries += 1;\n                }\n            }\n        }\n        \n        Err(NetworkError::DiscoveryFailed {\n            reason: \"All bootstrap nodes failed\".to_string(),\n        })\n    }\n    \n    /// Discover peers from bootstrap node\n    async fn discover_from_bootstrap(&mut self, addr: SocketAddr) -> NetworkResult<()> {\n        // In a real implementation, this would connect to the bootstrap node\n        // and request peer information. For now, we'll simulate it.\n        \n        tracing::info!(\"Discovering peers from bootstrap node: {}\", addr);\n        \n        // Simulate discovery delay\n        tokio::time::sleep(Duration::from_millis(100)).await;\n        \n        // Create mock bootstrap peers\n        let mock_peers = self.create_mock_bootstrap_peers(addr);\n        \n        for peer_info in mock_peers {\n            self.add_discovered_peer(peer_info, DiscoverySource::Bootstrap)?;\n        }\n        \n        Ok(())\n    }\n    \n    /// Create mock bootstrap peers for testing\n    fn create_mock_bootstrap_peers(&self, bootstrap_addr: SocketAddr) -> Vec<PeerInfo> {\n        let mut peers = Vec::new();\n        \n        // Create a few mock peers based on bootstrap address\n        for i in 1..=3 {\n            let mut addr = bootstrap_addr;\n            addr.set_port(addr.port() + i);\n            \n            let peer_id = PeerId::new(Hash256::from([\n                (addr.port() % 256) as u8; 32\n            ]));\n            \n            let mut peer_info = PeerInfo::new(peer_id, vec![addr]);\n            peer_info.capabilities = PeerCapabilities {\n                full_node: true,\n                consensus: i <= 2, // First two support consensus\n                tx_relay: true,\n                archival: i == 1, // First one is archival\n                privacy_level: SecurityLevel::Level1,\n            };\n            \n            peers.push(peer_info);\n        }\n        \n        peers\n    }\n    \n    /// Run discovery round\n    pub async fn discovery_round(&mut self) -> NetworkResult<()> {\n        if self.state != DiscoveryState::Active {\n            return Err(NetworkError::DiscoveryFailed {\n                reason: \"Discovery not active\".to_string(),\n            });\n        }\n        \n        self.stats.discovery_rounds += 1;\n        \n        // Clean up old peers\n        self.cleanup_old_peers();\n        \n        // Request peer exchanges from known peers\n        self.request_peer_exchanges().await?;\n        \n        // Update statistics\n        self.stats.last_discovery = Some(\n            SystemTime::now()\n                .duration_since(UNIX_EPOCH)\n                .unwrap()\n                .as_secs()\n        );\n        \n        Ok(())\n    }\n    \n    /// Request peer exchanges from connected peers\n    async fn request_peer_exchanges(&mut self) -> NetworkResult<()> {\n        let now = SystemTime::now()\n            .duration_since(UNIX_EPOCH)\n            .unwrap()\n            .as_secs();\n        \n        let mut exchange_count = 0;\n        \n        for (peer_id, peer_info) in &self.known_peers {\n            // Check if enough time has passed since last exchange\n            if let Some(&last_exchange) = self.last_peer_exchange.get(peer_id) {\n                if now - last_exchange < self.config.min_peer_exchange_interval {\n                    continue;\n                }\n            }\n            \n            // Only exchange with verified, connected peers\n            if peer_info.verified && peer_info.peer_info.is_online() {\n                self.request_peer_exchange(peer_id.clone()).await?;\n                self.last_peer_exchange.insert(peer_id.clone(), now);\n                exchange_count += 1;\n                \n                if exchange_count >= self.config.max_peers_per_round {\n                    break;\n                }\n            }\n        }\n        \n        Ok(())\n    }\n    \n    /// Request peer exchange from specific peer\n    async fn request_peer_exchange(&mut self, peer_id: PeerId) -> NetworkResult<()> {\n        let request_id = Hash256::from(rand::random::<[u8; 32]>());\n        \n        let request = DiscoveryRequest {\n            request_id,\n            target_peer: peer_id.clone(),\n            timestamp: SystemTime::now()\n                .duration_since(UNIX_EPOCH)\n                .unwrap()\n                .as_secs(),\n            request_type: DiscoveryRequestType::PeerExchange,\n        };\n        \n        self.pending_requests.insert(request_id, request);\n        \n        // In a real implementation, this would send a discovery message\n        tracing::debug!(\"Requesting peer exchange from: {:?}\", peer_id);\n        \n        Ok(())\n    }\n    \n    /// Handle discovery message\n    pub async fn handle_discovery_message(\n        &mut self,\n        message: &NetworkMessage,\n    ) -> NetworkResult<Option<NetworkMessage>> {\n        match &message.payload {\n            MessagePayload::Discovery(discovery) => {\n                self.process_discovery_payload(discovery, &message.sender).await\n            }\n            _ => Err(NetworkError::MessageError {\n                reason: \"Invalid discovery message payload\".to_string(),\n            }),\n        }\n    }\n    \n    /// Process discovery payload\n    async fn process_discovery_payload(\n        &mut self,\n        discovery: &DiscoveryPayload,\n        sender: &PeerId,\n    ) -> NetworkResult<Option<NetworkMessage>> {\n        match discovery.request_type.as_str() {\n            \"peer_exchange\" => {\n                // Add discovered peers\n                for peer_payload in &discovery.peers {\n                    if let Ok(peer_info) = self.peer_info_from_payload(peer_payload) {\n                        self.add_discovered_peer(\n                            peer_info,\n                            DiscoverySource::PeerExchange(sender.clone()),\n                        )?;\n                    }\n                }\n                \n                // Send our known peers back\n                self.create_peer_exchange_response(sender.clone()).await\n            }\n            \"bootstrap\" => {\n                // Handle bootstrap request\n                self.create_bootstrap_response(sender.clone()).await\n            }\n            _ => Ok(None),\n        }\n    }\n    \n    /// Create peer exchange response\n    async fn create_peer_exchange_response(\n        &self,\n        recipient: PeerId,\n    ) -> NetworkResult<Option<NetworkMessage>> {\n        let our_peers: Vec<PeerInfoPayload> = self\n            .known_peers\n            .values()\n            .filter(|info| info.verified)\n            .take(self.config.max_peers_per_round)\n            .map(|info| self.peer_info_to_payload(&info.peer_info))\n            .collect();\n        \n        let discovery_payload = DiscoveryPayload {\n            peers: our_peers,\n            request_type: \"peer_exchange_response\".to_string(),\n        };\n        \n        let message = NetworkMessage::new(\n            MessageType::Discovery,\n            PeerId::from_identity(&self.identity),\n            Some(recipient),\n            MessagePayload::Discovery(discovery_payload),\n        );\n        \n        Ok(Some(message))\n    }\n    \n    /// Create bootstrap response\n    async fn create_bootstrap_response(\n        &self,\n        recipient: PeerId,\n    ) -> NetworkResult<Option<NetworkMessage>> {\n        let bootstrap_peers: Vec<PeerInfoPayload> = self\n            .known_peers\n            .values()\n            .filter(|info| info.verified && info.peer_info.capabilities.full_node)\n            .take(10) // Send more peers for bootstrap\n            .map(|info| self.peer_info_to_payload(&info.peer_info))\n            .collect();\n        \n        let discovery_payload = DiscoveryPayload {\n            peers: bootstrap_peers,\n            request_type: \"bootstrap_response\".to_string(),\n        };\n        \n        let message = NetworkMessage::new(\n            MessageType::Discovery,\n            PeerId::from_identity(&self.identity),\n            Some(recipient),\n            MessagePayload::Discovery(discovery_payload),\n        );\n        \n        Ok(Some(message))\n    }\n    \n    /// Add discovered peer\n    fn add_discovered_peer(\n        &mut self,\n        peer_info: PeerInfo,\n        source: DiscoverySource,\n    ) -> NetworkResult<()> {\n        let peer_id = peer_info.id.clone();\n        let now = SystemTime::now()\n            .duration_since(UNIX_EPOCH)\n            .unwrap()\n            .as_secs();\n        \n        // Don't add ourselves\n        if peer_id == PeerId::from_identity(&self.identity) {\n            return Ok(());\n        }\n        \n        let discovery_info = PeerDiscoveryInfo {\n            peer_info,\n            discovered_at: now,\n            last_seen: now,\n            source,\n            verified: false, // Will be verified during handshake\n        };\n        \n        if self.known_peers.insert(peer_id, discovery_info).is_none() {\n            self.stats.peers_discovered += 1;\n        }\n        \n        Ok(())\n    }\n    \n    /// Convert peer info to payload\n    fn peer_info_to_payload(&self, peer_info: &PeerInfo) -> PeerInfoPayload {\n        PeerInfoPayload {\n            peer_id: peer_info.id.clone(),\n            addresses: peer_info\n                .addresses\n                .iter()\n                .map(|addr| addr.to_string())\n                .collect(),\n            last_seen: peer_info.last_seen,\n            capabilities: vec![\n                if peer_info.capabilities.full_node {\n                    \"full-node\".to_string()\n                } else {\n                    \"light-node\".to_string()\n                },\n                if peer_info.capabilities.consensus {\n                    \"consensus\".to_string()\n                } else {\n                    \"no-consensus\".to_string()\n                },\n            ],\n        }\n    }\n    \n    /// Convert payload to peer info\n    fn peer_info_from_payload(&self, payload: &PeerInfoPayload) -> NetworkResult<PeerInfo> {\n        let addresses: Result<Vec<SocketAddr>, _> = payload\n            .addresses\n            .iter()\n            .map(|addr_str| addr_str.parse())\n            .collect();\n        \n        let addresses = addresses.map_err(|e| NetworkError::DiscoveryFailed {\n            reason: format!(\"Invalid peer address: {}\", e),\n        })?;\n        \n        let mut peer_info = PeerInfo::new(payload.peer_id.clone(), addresses);\n        peer_info.last_seen = payload.last_seen;\n        \n        // Parse capabilities\n        peer_info.capabilities.full_node = payload.capabilities.contains(&\"full-node\".to_string());\n        peer_info.capabilities.consensus = payload.capabilities.contains(&\"consensus\".to_string());\n        \n        Ok(peer_info)\n    }\n    \n    /// Mark peer as verified\n    pub fn verify_peer(&mut self, peer_id: &PeerId) -> NetworkResult<()> {\n        if let Some(discovery_info) = self.known_peers.get_mut(peer_id) {\n            discovery_info.verified = true;\n            discovery_info.last_seen = SystemTime::now()\n                .duration_since(UNIX_EPOCH)\n                .unwrap()\n                .as_secs();\n            Ok(())\n        } else {\n            Err(NetworkError::PeerError {\n                reason: \"Peer not found for verification\".to_string(),\n            })\n        }\n    }\n    \n    /// Get known peers\n    pub fn get_known_peers(&self) -> Vec<&PeerInfo> {\n        self.known_peers\n            .values()\n            .map(|info| &info.peer_info)\n            .collect()\n    }\n    \n    /// Get verified peers\n    pub fn get_verified_peers(&self) -> Vec<&PeerInfo> {\n        self.known_peers\n            .values()\n            .filter(|info| info.verified)\n            .map(|info| &info.peer_info)\n            .collect()\n    }\n    \n    /// Cleanup old peers\n    fn cleanup_old_peers(&mut self) {\n        let now = SystemTime::now()\n            .duration_since(UNIX_EPOCH)\n            .unwrap()\n            .as_secs();\n        \n        let old_peers: Vec<PeerId> = self\n            .known_peers\n            .iter()\n            .filter(|(_, info)| now - info.last_seen > self.config.max_peer_age)\n            .map(|(peer_id, _)| peer_id.clone())\n            .collect();\n        \n        for peer_id in old_peers {\n            self.known_peers.remove(&peer_id);\n            self.last_peer_exchange.remove(&peer_id);\n        }\n    }\n    \n    /// Get discovery state\n    pub fn state(&self) -> &DiscoveryState {\n        &self.state\n    }\n    \n    /// Get discovery statistics\n    pub fn stats(&self) -> &DiscoveryStats {\n        &self.stats\n    }\n    \n    /// Get peer count\n    pub fn peer_count(&self) -> usize {\n        self.known_peers.len()\n    }\n    \n    /// Get verified peer count\n    pub fn verified_peer_count(&self) -> usize {\n        self.known_peers.values().filter(|info| info.verified).count()\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use nym_crypto::{QuIDAuth, SecurityLevel};\n    \n    fn create_test_identity() -> NymIdentity {\n        let quid_auth = QuIDAuth::new(vec![1u8; 32], SecurityLevel::Level1);\n        quid_auth.create_nym_identity(0).unwrap()\n    }\n    \n    #[test]\n    fn test_discovery_config_default() {\n        let config = DiscoveryConfig::default();\n        assert_eq!(config.bootstrap_nodes.len(), 2);\n        assert_eq!(config.discovery_interval, 300);\n    }\n    \n    #[test]\n    fn test_node_discovery_creation() {\n        let config = DiscoveryConfig::default();\n        let identity = create_test_identity();\n        let discovery = NodeDiscovery::new(config, identity);\n        \n        assert_eq!(discovery.state, DiscoveryState::Initializing);\n        assert_eq!(discovery.peer_count(), 0);\n    }\n    \n    #[tokio::test]\n    async fn test_bootstrap() {\n        let config = DiscoveryConfig::default();\n        let identity = create_test_identity();\n        let mut discovery = NodeDiscovery::new(config, identity);\n        \n        // Simulate bootstrap\n        let result = discovery.start().await;\n        assert!(result.is_ok());\n        assert_eq!(discovery.state, DiscoveryState::Active);\n        \n        // Should have discovered some peers\n        assert!(discovery.peer_count() > 0);\n    }\n    \n    #[test]\n    fn test_add_discovered_peer() {\n        let config = DiscoveryConfig::default();\n        let identity = create_test_identity();\n        let mut discovery = NodeDiscovery::new(config, identity);\n        \n        let peer_id = PeerId::new(Hash256::from([2u8; 32]));\n        let addr = \"127.0.0.1:8080\".parse().unwrap();\n        let peer_info = PeerInfo::new(peer_id.clone(), vec![addr]);\n        \n        let result = discovery.add_discovered_peer(peer_info, DiscoverySource::Bootstrap);\n        assert!(result.is_ok());\n        assert_eq!(discovery.peer_count(), 1);\n        \n        let known_peers = discovery.get_known_peers();\n        assert_eq!(known_peers.len(), 1);\n        assert_eq!(known_peers[0].id, peer_id);\n    }\n    \n    #[test]\n    fn test_peer_verification() {\n        let config = DiscoveryConfig::default();\n        let identity = create_test_identity();\n        let mut discovery = NodeDiscovery::new(config, identity);\n        \n        let peer_id = PeerId::new(Hash256::from([2u8; 32]));\n        let addr = \"127.0.0.1:8080\".parse().unwrap();\n        let peer_info = PeerInfo::new(peer_id.clone(), vec![addr]);\n        \n        discovery.add_discovered_peer(peer_info, DiscoverySource::Bootstrap).unwrap();\n        assert_eq!(discovery.verified_peer_count(), 0);\n        \n        discovery.verify_peer(&peer_id).unwrap();\n        assert_eq!(discovery.verified_peer_count(), 1);\n    }\n    \n    #[test]\n    fn test_peer_info_payload_conversion() {\n        let config = DiscoveryConfig::default();\n        let identity = create_test_identity();\n        let discovery = NodeDiscovery::new(config, identity);\n        \n        let peer_id = PeerId::new(Hash256::from([2u8; 32]));\n        let addr = \"127.0.0.1:8080\".parse().unwrap();\n        let peer_info = PeerInfo::new(peer_id.clone(), vec![addr]);\n        \n        let payload = discovery.peer_info_to_payload(&peer_info);\n        assert_eq!(payload.peer_id, peer_id);\n        assert_eq!(payload.addresses.len(), 1);\n        assert_eq!(payload.addresses[0], \"127.0.0.1:8080\");\n        \n        let converted_back = discovery.peer_info_from_payload(&payload).unwrap();\n        assert_eq!(converted_back.id, peer_id);\n        assert_eq!(converted_back.addresses.len(), 1);\n    }\n}"